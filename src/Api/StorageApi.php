<?php
/**
 * StorageApi
 * PHP version 7.4
 *
 * @category Class
 * @package  ZSGF\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * 全部  API 文档
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.13.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace ZSGF\Client\ZSGF\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use ZSGF\Client\ApiException;
use ZSGF\Client\Configuration;
use ZSGF\Client\HeaderSelector;
use ZSGF\Client\ObjectSerializer;

/**
 * StorageApi Class Doc Comment
 *
 * @category Class
 * @package  ZSGF\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class StorageApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'storageAggregate' => [
            'application/json',
        ],
        'storageBatchUpdate' => [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/*+json',
        ],
        'storageClear' => [
            'application/json',
        ],
        'storageDelete' => [
            'application/json',
        ],
        'storageDeleteIndex' => [
            'application/json',
        ],
        'storageDetail' => [
            'application/json',
        ],
        'storageExecuteFunction' => [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/*+json',
        ],
        'storageExport' => [
            'application/json',
        ],
        'storageImport' => [
            'multipart/form-data',
        ],
        'storageIndexes' => [
            'application/json',
        ],
        'storageList' => [
            'application/json',
        ],
        'storagePost' => [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/*+json',
        ],
        'storagePostIndex' => [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/*+json',
        ],
        'storagePut' => [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/*+json',
        ],
        'storageRemove' => [
            'application/json',
        ],
        'storageStats' => [
            'application/json',
        ],
        'storageTables' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation storageAggregate
     *
     * 聚合查询
     *
     * @param  string $table 表名称 (required)
     * @param  string $app_key app_key (required)
     * @param  string|null $pipeline 构建聚合查询 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageAggregate'] to see the possible values for this operation
     *
     * @throws \ZSGF\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \ZSGF\Client\ZSGF\Client\Model\ObjectListApiResponse
     */
    public function storageAggregate($table, $app_key, $pipeline = null, string $contentType = self::contentTypes['storageAggregate'][0])
    {
        list($response) = $this->storageAggregateWithHttpInfo($table, $app_key, $pipeline, $contentType);
        return $response;
    }

    /**
     * Operation storageAggregateWithHttpInfo
     *
     * 聚合查询
     *
     * @param  string $table 表名称 (required)
     * @param  string $app_key (required)
     * @param  string|null $pipeline 构建聚合查询 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageAggregate'] to see the possible values for this operation
     *
     * @throws \ZSGF\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \ZSGF\Client\ZSGF\Client\Model\ObjectListApiResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function storageAggregateWithHttpInfo($table, $app_key, $pipeline = null, string $contentType = self::contentTypes['storageAggregate'][0])
    {
        $request = $this->storageAggregateRequest($table, $app_key, $pipeline, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\ZSGF\Client\ZSGF\Client\Model\ObjectListApiResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ZSGF\Client\ZSGF\Client\Model\ObjectListApiResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ZSGF\Client\ZSGF\Client\Model\ObjectListApiResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\ZSGF\Client\ZSGF\Client\Model\ObjectListApiResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ZSGF\Client\ZSGF\Client\Model\ObjectListApiResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation storageAggregateAsync
     *
     * 聚合查询
     *
     * @param  string $table 表名称 (required)
     * @param  string $app_key (required)
     * @param  string|null $pipeline 构建聚合查询 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageAggregate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storageAggregateAsync($table, $app_key, $pipeline = null, string $contentType = self::contentTypes['storageAggregate'][0])
    {
        return $this->storageAggregateAsyncWithHttpInfo($table, $app_key, $pipeline, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storageAggregateAsyncWithHttpInfo
     *
     * 聚合查询
     *
     * @param  string $table 表名称 (required)
     * @param  string $app_key (required)
     * @param  string|null $pipeline 构建聚合查询 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageAggregate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storageAggregateAsyncWithHttpInfo($table, $app_key, $pipeline = null, string $contentType = self::contentTypes['storageAggregate'][0])
    {
        $returnType = '\ZSGF\Client\ZSGF\Client\Model\ObjectListApiResponse';
        $request = $this->storageAggregateRequest($table, $app_key, $pipeline, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'storageAggregate'
     *
     * @param  string $table 表名称 (required)
     * @param  string $app_key (required)
     * @param  string|null $pipeline 构建聚合查询 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageAggregate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function storageAggregateRequest($table, $app_key, $pipeline = null, string $contentType = self::contentTypes['storageAggregate'][0])
    {

        // verify the required parameter 'table' is set
        if ($table === null || (is_array($table) && count($table) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $table when calling storageAggregate'
            );
        }
        if (!preg_match("/^[a-zA-Z0-9_-]{1,100}$/", $table)) {
            throw new \InvalidArgumentException("invalid value for \"table\" when calling StorageApi.storageAggregate, must conform to the pattern /^[a-zA-Z0-9_-]{1,100}$/.");
        }
        
        // verify the required parameter 'app_key' is set
        if ($app_key === null || (is_array($app_key) && count($app_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_key when calling storageAggregate'
            );
        }



        $resourcePath = '/Storage/{appKey}/{table}/Aggregate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pipeline,
            'pipeline', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($table !== null) {
            $resourcePath = str_replace(
                '{' . 'table' . '}',
                ObjectSerializer::toPathValue($table),
                $resourcePath
            );
        }
        // path params
        if ($app_key !== null) {
            $resourcePath = str_replace(
                '{' . 'appKey' . '}',
                ObjectSerializer::toPathValue($app_key),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation storageBatchUpdate
     *
     * 批量更新指定条件的数据
     *
     * @param  string $table 表名称 (required)
     * @param  string $filter 查询条件 (required)
     * @param  string $app_key app_key (required)
     * @param  mixed[] $request_body 更新的字段 (required)
     * @param  bool|null $replace 是否为全量替换，默认为 false (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageBatchUpdate'] to see the possible values for this operation
     *
     * @throws \ZSGF\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \ZSGF\Client\ZSGF\Client\Model\BooleanApiResponse
     */
    public function storageBatchUpdate($table, $filter, $app_key, $request_body, $replace = false, string $contentType = self::contentTypes['storageBatchUpdate'][0])
    {
        list($response) = $this->storageBatchUpdateWithHttpInfo($table, $filter, $app_key, $request_body, $replace, $contentType);
        return $response;
    }

    /**
     * Operation storageBatchUpdateWithHttpInfo
     *
     * 批量更新指定条件的数据
     *
     * @param  string $table 表名称 (required)
     * @param  string $filter 查询条件 (required)
     * @param  string $app_key (required)
     * @param  mixed[] $request_body 更新的字段 (required)
     * @param  bool|null $replace 是否为全量替换，默认为 false (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageBatchUpdate'] to see the possible values for this operation
     *
     * @throws \ZSGF\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \ZSGF\Client\ZSGF\Client\Model\BooleanApiResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function storageBatchUpdateWithHttpInfo($table, $filter, $app_key, $request_body, $replace = false, string $contentType = self::contentTypes['storageBatchUpdate'][0])
    {
        $request = $this->storageBatchUpdateRequest($table, $filter, $app_key, $request_body, $replace, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\ZSGF\Client\ZSGF\Client\Model\BooleanApiResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ZSGF\Client\ZSGF\Client\Model\BooleanApiResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ZSGF\Client\ZSGF\Client\Model\BooleanApiResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\ZSGF\Client\ZSGF\Client\Model\BooleanApiResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ZSGF\Client\ZSGF\Client\Model\BooleanApiResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation storageBatchUpdateAsync
     *
     * 批量更新指定条件的数据
     *
     * @param  string $table 表名称 (required)
     * @param  string $filter 查询条件 (required)
     * @param  string $app_key (required)
     * @param  mixed[] $request_body 更新的字段 (required)
     * @param  bool|null $replace 是否为全量替换，默认为 false (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageBatchUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storageBatchUpdateAsync($table, $filter, $app_key, $request_body, $replace = false, string $contentType = self::contentTypes['storageBatchUpdate'][0])
    {
        return $this->storageBatchUpdateAsyncWithHttpInfo($table, $filter, $app_key, $request_body, $replace, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storageBatchUpdateAsyncWithHttpInfo
     *
     * 批量更新指定条件的数据
     *
     * @param  string $table 表名称 (required)
     * @param  string $filter 查询条件 (required)
     * @param  string $app_key (required)
     * @param  mixed[] $request_body 更新的字段 (required)
     * @param  bool|null $replace 是否为全量替换，默认为 false (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageBatchUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storageBatchUpdateAsyncWithHttpInfo($table, $filter, $app_key, $request_body, $replace = false, string $contentType = self::contentTypes['storageBatchUpdate'][0])
    {
        $returnType = '\ZSGF\Client\ZSGF\Client\Model\BooleanApiResponse';
        $request = $this->storageBatchUpdateRequest($table, $filter, $app_key, $request_body, $replace, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'storageBatchUpdate'
     *
     * @param  string $table 表名称 (required)
     * @param  string $filter 查询条件 (required)
     * @param  string $app_key (required)
     * @param  mixed[] $request_body 更新的字段 (required)
     * @param  bool|null $replace 是否为全量替换，默认为 false (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageBatchUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function storageBatchUpdateRequest($table, $filter, $app_key, $request_body, $replace = false, string $contentType = self::contentTypes['storageBatchUpdate'][0])
    {

        // verify the required parameter 'table' is set
        if ($table === null || (is_array($table) && count($table) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $table when calling storageBatchUpdate'
            );
        }
        if (!preg_match("/^[a-zA-Z0-9_-]{1,100}$/", $table)) {
            throw new \InvalidArgumentException("invalid value for \"table\" when calling StorageApi.storageBatchUpdate, must conform to the pattern /^[a-zA-Z0-9_-]{1,100}$/.");
        }
        
        // verify the required parameter 'filter' is set
        if ($filter === null || (is_array($filter) && count($filter) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $filter when calling storageBatchUpdate'
            );
        }

        // verify the required parameter 'app_key' is set
        if ($app_key === null || (is_array($app_key) && count($app_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_key when calling storageBatchUpdate'
            );
        }

        // verify the required parameter 'request_body' is set
        if ($request_body === null || (is_array($request_body) && count($request_body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request_body when calling storageBatchUpdate'
            );
        }



        $resourcePath = '/Storage/{appKey}/{table}/batch-update';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $filter,
            'filter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $replace,
            'replace', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($table !== null) {
            $resourcePath = str_replace(
                '{' . 'table' . '}',
                ObjectSerializer::toPathValue($table),
                $resourcePath
            );
        }
        // path params
        if ($app_key !== null) {
            $resourcePath = str_replace(
                '{' . 'appKey' . '}',
                ObjectSerializer::toPathValue($app_key),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($request_body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($request_body));
            } else {
                $httpBody = $request_body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation storageClear
     *
     * 清空表数据
     *
     * @param  string $table 表名称 (required)
     * @param  string $app_key app_key (required)
     * @param  string|null $filter 筛选条件，json格式 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageClear'] to see the possible values for this operation
     *
     * @throws \ZSGF\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \ZSGF\Client\ZSGF\Client\Model\Int64ApiResponse
     */
    public function storageClear($table, $app_key, $filter = null, string $contentType = self::contentTypes['storageClear'][0])
    {
        list($response) = $this->storageClearWithHttpInfo($table, $app_key, $filter, $contentType);
        return $response;
    }

    /**
     * Operation storageClearWithHttpInfo
     *
     * 清空表数据
     *
     * @param  string $table 表名称 (required)
     * @param  string $app_key (required)
     * @param  string|null $filter 筛选条件，json格式 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageClear'] to see the possible values for this operation
     *
     * @throws \ZSGF\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \ZSGF\Client\ZSGF\Client\Model\Int64ApiResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function storageClearWithHttpInfo($table, $app_key, $filter = null, string $contentType = self::contentTypes['storageClear'][0])
    {
        $request = $this->storageClearRequest($table, $app_key, $filter, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\ZSGF\Client\ZSGF\Client\Model\Int64ApiResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ZSGF\Client\ZSGF\Client\Model\Int64ApiResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ZSGF\Client\ZSGF\Client\Model\Int64ApiResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\ZSGF\Client\ZSGF\Client\Model\Int64ApiResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ZSGF\Client\ZSGF\Client\Model\Int64ApiResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation storageClearAsync
     *
     * 清空表数据
     *
     * @param  string $table 表名称 (required)
     * @param  string $app_key (required)
     * @param  string|null $filter 筛选条件，json格式 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageClear'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storageClearAsync($table, $app_key, $filter = null, string $contentType = self::contentTypes['storageClear'][0])
    {
        return $this->storageClearAsyncWithHttpInfo($table, $app_key, $filter, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storageClearAsyncWithHttpInfo
     *
     * 清空表数据
     *
     * @param  string $table 表名称 (required)
     * @param  string $app_key (required)
     * @param  string|null $filter 筛选条件，json格式 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageClear'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storageClearAsyncWithHttpInfo($table, $app_key, $filter = null, string $contentType = self::contentTypes['storageClear'][0])
    {
        $returnType = '\ZSGF\Client\ZSGF\Client\Model\Int64ApiResponse';
        $request = $this->storageClearRequest($table, $app_key, $filter, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'storageClear'
     *
     * @param  string $table 表名称 (required)
     * @param  string $app_key (required)
     * @param  string|null $filter 筛选条件，json格式 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageClear'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function storageClearRequest($table, $app_key, $filter = null, string $contentType = self::contentTypes['storageClear'][0])
    {

        // verify the required parameter 'table' is set
        if ($table === null || (is_array($table) && count($table) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $table when calling storageClear'
            );
        }
        if (!preg_match("/^[a-zA-Z0-9_-]{1,100}$/", $table)) {
            throw new \InvalidArgumentException("invalid value for \"table\" when calling StorageApi.storageClear, must conform to the pattern /^[a-zA-Z0-9_-]{1,100}$/.");
        }
        
        // verify the required parameter 'app_key' is set
        if ($app_key === null || (is_array($app_key) && count($app_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_key when calling storageClear'
            );
        }



        $resourcePath = '/Storage/{appKey}/{table}/Clear';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $filter,
            'filter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($table !== null) {
            $resourcePath = str_replace(
                '{' . 'table' . '}',
                ObjectSerializer::toPathValue($table),
                $resourcePath
            );
        }
        // path params
        if ($app_key !== null) {
            $resourcePath = str_replace(
                '{' . 'appKey' . '}',
                ObjectSerializer::toPathValue($app_key),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation storageDelete
     *
     * 删除数据
     *
     * @param  string $table 表名称 (required)
     * @param  string $id 数据ID (required)
     * @param  string $app_key app_key (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageDelete'] to see the possible values for this operation
     *
     * @throws \ZSGF\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \ZSGF\Client\ZSGF\Client\Model\BooleanApiResponse
     */
    public function storageDelete($table, $id, $app_key, string $contentType = self::contentTypes['storageDelete'][0])
    {
        list($response) = $this->storageDeleteWithHttpInfo($table, $id, $app_key, $contentType);
        return $response;
    }

    /**
     * Operation storageDeleteWithHttpInfo
     *
     * 删除数据
     *
     * @param  string $table 表名称 (required)
     * @param  string $id 数据ID (required)
     * @param  string $app_key (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageDelete'] to see the possible values for this operation
     *
     * @throws \ZSGF\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \ZSGF\Client\ZSGF\Client\Model\BooleanApiResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function storageDeleteWithHttpInfo($table, $id, $app_key, string $contentType = self::contentTypes['storageDelete'][0])
    {
        $request = $this->storageDeleteRequest($table, $id, $app_key, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\ZSGF\Client\ZSGF\Client\Model\BooleanApiResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ZSGF\Client\ZSGF\Client\Model\BooleanApiResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ZSGF\Client\ZSGF\Client\Model\BooleanApiResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\ZSGF\Client\ZSGF\Client\Model\BooleanApiResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ZSGF\Client\ZSGF\Client\Model\BooleanApiResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation storageDeleteAsync
     *
     * 删除数据
     *
     * @param  string $table 表名称 (required)
     * @param  string $id 数据ID (required)
     * @param  string $app_key (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storageDeleteAsync($table, $id, $app_key, string $contentType = self::contentTypes['storageDelete'][0])
    {
        return $this->storageDeleteAsyncWithHttpInfo($table, $id, $app_key, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storageDeleteAsyncWithHttpInfo
     *
     * 删除数据
     *
     * @param  string $table 表名称 (required)
     * @param  string $id 数据ID (required)
     * @param  string $app_key (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storageDeleteAsyncWithHttpInfo($table, $id, $app_key, string $contentType = self::contentTypes['storageDelete'][0])
    {
        $returnType = '\ZSGF\Client\ZSGF\Client\Model\BooleanApiResponse';
        $request = $this->storageDeleteRequest($table, $id, $app_key, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'storageDelete'
     *
     * @param  string $table 表名称 (required)
     * @param  string $id 数据ID (required)
     * @param  string $app_key (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function storageDeleteRequest($table, $id, $app_key, string $contentType = self::contentTypes['storageDelete'][0])
    {

        // verify the required parameter 'table' is set
        if ($table === null || (is_array($table) && count($table) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $table when calling storageDelete'
            );
        }
        if (!preg_match("/^[a-zA-Z0-9_-]{1,100}$/", $table)) {
            throw new \InvalidArgumentException("invalid value for \"table\" when calling StorageApi.storageDelete, must conform to the pattern /^[a-zA-Z0-9_-]{1,100}$/.");
        }
        
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling storageDelete'
            );
        }

        // verify the required parameter 'app_key' is set
        if ($app_key === null || (is_array($app_key) && count($app_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_key when calling storageDelete'
            );
        }


        $resourcePath = '/Storage/{appKey}/{table}/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($table !== null) {
            $resourcePath = str_replace(
                '{' . 'table' . '}',
                ObjectSerializer::toPathValue($table),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($app_key !== null) {
            $resourcePath = str_replace(
                '{' . 'appKey' . '}',
                ObjectSerializer::toPathValue($app_key),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation storageDeleteIndex
     *
     * 删除索引
     *
     * @param  string $table 表名称 (required)
     * @param  string $app_key app_key (required)
     * @param  string|null $index_name 索引名称 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageDeleteIndex'] to see the possible values for this operation
     *
     * @throws \ZSGF\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \ZSGF\Client\ZSGF\Client\Model\BooleanApiResponse
     */
    public function storageDeleteIndex($table, $app_key, $index_name = null, string $contentType = self::contentTypes['storageDeleteIndex'][0])
    {
        list($response) = $this->storageDeleteIndexWithHttpInfo($table, $app_key, $index_name, $contentType);
        return $response;
    }

    /**
     * Operation storageDeleteIndexWithHttpInfo
     *
     * 删除索引
     *
     * @param  string $table 表名称 (required)
     * @param  string $app_key (required)
     * @param  string|null $index_name 索引名称 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageDeleteIndex'] to see the possible values for this operation
     *
     * @throws \ZSGF\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \ZSGF\Client\ZSGF\Client\Model\BooleanApiResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function storageDeleteIndexWithHttpInfo($table, $app_key, $index_name = null, string $contentType = self::contentTypes['storageDeleteIndex'][0])
    {
        $request = $this->storageDeleteIndexRequest($table, $app_key, $index_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\ZSGF\Client\ZSGF\Client\Model\BooleanApiResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ZSGF\Client\ZSGF\Client\Model\BooleanApiResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ZSGF\Client\ZSGF\Client\Model\BooleanApiResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\ZSGF\Client\ZSGF\Client\Model\BooleanApiResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ZSGF\Client\ZSGF\Client\Model\BooleanApiResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation storageDeleteIndexAsync
     *
     * 删除索引
     *
     * @param  string $table 表名称 (required)
     * @param  string $app_key (required)
     * @param  string|null $index_name 索引名称 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageDeleteIndex'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storageDeleteIndexAsync($table, $app_key, $index_name = null, string $contentType = self::contentTypes['storageDeleteIndex'][0])
    {
        return $this->storageDeleteIndexAsyncWithHttpInfo($table, $app_key, $index_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storageDeleteIndexAsyncWithHttpInfo
     *
     * 删除索引
     *
     * @param  string $table 表名称 (required)
     * @param  string $app_key (required)
     * @param  string|null $index_name 索引名称 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageDeleteIndex'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storageDeleteIndexAsyncWithHttpInfo($table, $app_key, $index_name = null, string $contentType = self::contentTypes['storageDeleteIndex'][0])
    {
        $returnType = '\ZSGF\Client\ZSGF\Client\Model\BooleanApiResponse';
        $request = $this->storageDeleteIndexRequest($table, $app_key, $index_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'storageDeleteIndex'
     *
     * @param  string $table 表名称 (required)
     * @param  string $app_key (required)
     * @param  string|null $index_name 索引名称 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageDeleteIndex'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function storageDeleteIndexRequest($table, $app_key, $index_name = null, string $contentType = self::contentTypes['storageDeleteIndex'][0])
    {

        // verify the required parameter 'table' is set
        if ($table === null || (is_array($table) && count($table) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $table when calling storageDeleteIndex'
            );
        }
        if (!preg_match("/^[a-zA-Z0-9_-]{1,100}$/", $table)) {
            throw new \InvalidArgumentException("invalid value for \"table\" when calling StorageApi.storageDeleteIndex, must conform to the pattern /^[a-zA-Z0-9_-]{1,100}$/.");
        }
        
        // verify the required parameter 'app_key' is set
        if ($app_key === null || (is_array($app_key) && count($app_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_key when calling storageDeleteIndex'
            );
        }



        $resourcePath = '/Storage/{appKey}/{table}/indexes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $index_name,
            'indexName', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($table !== null) {
            $resourcePath = str_replace(
                '{' . 'table' . '}',
                ObjectSerializer::toPathValue($table),
                $resourcePath
            );
        }
        // path params
        if ($app_key !== null) {
            $resourcePath = str_replace(
                '{' . 'appKey' . '}',
                ObjectSerializer::toPathValue($app_key),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation storageDetail
     *
     * 数据详情
     *
     * @param  string $table 表名称 (required)
     * @param  string $id 数据ID (required)
     * @param  string $app_key app_key (required)
     * @param  string|null $project json格式 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageDetail'] to see the possible values for this operation
     *
     * @throws \ZSGF\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \ZSGF\Client\ZSGF\Client\Model\ObjectApiResponse
     */
    public function storageDetail($table, $id, $app_key, $project = null, string $contentType = self::contentTypes['storageDetail'][0])
    {
        list($response) = $this->storageDetailWithHttpInfo($table, $id, $app_key, $project, $contentType);
        return $response;
    }

    /**
     * Operation storageDetailWithHttpInfo
     *
     * 数据详情
     *
     * @param  string $table 表名称 (required)
     * @param  string $id 数据ID (required)
     * @param  string $app_key (required)
     * @param  string|null $project json格式 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageDetail'] to see the possible values for this operation
     *
     * @throws \ZSGF\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \ZSGF\Client\ZSGF\Client\Model\ObjectApiResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function storageDetailWithHttpInfo($table, $id, $app_key, $project = null, string $contentType = self::contentTypes['storageDetail'][0])
    {
        $request = $this->storageDetailRequest($table, $id, $app_key, $project, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\ZSGF\Client\ZSGF\Client\Model\ObjectApiResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ZSGF\Client\ZSGF\Client\Model\ObjectApiResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ZSGF\Client\ZSGF\Client\Model\ObjectApiResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\ZSGF\Client\ZSGF\Client\Model\ObjectApiResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ZSGF\Client\ZSGF\Client\Model\ObjectApiResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation storageDetailAsync
     *
     * 数据详情
     *
     * @param  string $table 表名称 (required)
     * @param  string $id 数据ID (required)
     * @param  string $app_key (required)
     * @param  string|null $project json格式 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageDetail'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storageDetailAsync($table, $id, $app_key, $project = null, string $contentType = self::contentTypes['storageDetail'][0])
    {
        return $this->storageDetailAsyncWithHttpInfo($table, $id, $app_key, $project, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storageDetailAsyncWithHttpInfo
     *
     * 数据详情
     *
     * @param  string $table 表名称 (required)
     * @param  string $id 数据ID (required)
     * @param  string $app_key (required)
     * @param  string|null $project json格式 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageDetail'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storageDetailAsyncWithHttpInfo($table, $id, $app_key, $project = null, string $contentType = self::contentTypes['storageDetail'][0])
    {
        $returnType = '\ZSGF\Client\ZSGF\Client\Model\ObjectApiResponse';
        $request = $this->storageDetailRequest($table, $id, $app_key, $project, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'storageDetail'
     *
     * @param  string $table 表名称 (required)
     * @param  string $id 数据ID (required)
     * @param  string $app_key (required)
     * @param  string|null $project json格式 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageDetail'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function storageDetailRequest($table, $id, $app_key, $project = null, string $contentType = self::contentTypes['storageDetail'][0])
    {

        // verify the required parameter 'table' is set
        if ($table === null || (is_array($table) && count($table) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $table when calling storageDetail'
            );
        }
        if (!preg_match("/^[a-zA-Z0-9_-]{1,100}$/", $table)) {
            throw new \InvalidArgumentException("invalid value for \"table\" when calling StorageApi.storageDetail, must conform to the pattern /^[a-zA-Z0-9_-]{1,100}$/.");
        }
        
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling storageDetail'
            );
        }

        // verify the required parameter 'app_key' is set
        if ($app_key === null || (is_array($app_key) && count($app_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_key when calling storageDetail'
            );
        }



        $resourcePath = '/Storage/{appKey}/{table}/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $project,
            'project', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($table !== null) {
            $resourcePath = str_replace(
                '{' . 'table' . '}',
                ObjectSerializer::toPathValue($table),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($app_key !== null) {
            $resourcePath = str_replace(
                '{' . 'appKey' . '}',
                ObjectSerializer::toPathValue($app_key),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation storageExecuteFunction
     *
     * 执行函数
     *
     * @param  string $nonce 随机字符串 (required)
     * @param  int $timestamp 时间戳 (required)
     * @param  string $signature 签名 (required)
     * @param  string $app_key app_key (required)
     * @param  \ZSGF\Client\ZSGF\Client\Model\ExecuteFunctionRequest|null $execute_function_request 函数请求参数 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageExecuteFunction'] to see the possible values for this operation
     *
     * @throws \ZSGF\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \ZSGF\Client\ZSGF\Client\Model\ObjectApiResponse
     */
    public function storageExecuteFunction($nonce, $timestamp, $signature, $app_key, $execute_function_request = null, string $contentType = self::contentTypes['storageExecuteFunction'][0])
    {
        list($response) = $this->storageExecuteFunctionWithHttpInfo($nonce, $timestamp, $signature, $app_key, $execute_function_request, $contentType);
        return $response;
    }

    /**
     * Operation storageExecuteFunctionWithHttpInfo
     *
     * 执行函数
     *
     * @param  string $nonce 随机字符串 (required)
     * @param  int $timestamp 时间戳 (required)
     * @param  string $signature 签名 (required)
     * @param  string $app_key (required)
     * @param  \ZSGF\Client\ZSGF\Client\Model\ExecuteFunctionRequest|null $execute_function_request 函数请求参数 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageExecuteFunction'] to see the possible values for this operation
     *
     * @throws \ZSGF\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \ZSGF\Client\ZSGF\Client\Model\ObjectApiResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function storageExecuteFunctionWithHttpInfo($nonce, $timestamp, $signature, $app_key, $execute_function_request = null, string $contentType = self::contentTypes['storageExecuteFunction'][0])
    {
        $request = $this->storageExecuteFunctionRequest($nonce, $timestamp, $signature, $app_key, $execute_function_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\ZSGF\Client\ZSGF\Client\Model\ObjectApiResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ZSGF\Client\ZSGF\Client\Model\ObjectApiResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ZSGF\Client\ZSGF\Client\Model\ObjectApiResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\ZSGF\Client\ZSGF\Client\Model\ObjectApiResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ZSGF\Client\ZSGF\Client\Model\ObjectApiResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation storageExecuteFunctionAsync
     *
     * 执行函数
     *
     * @param  string $nonce 随机字符串 (required)
     * @param  int $timestamp 时间戳 (required)
     * @param  string $signature 签名 (required)
     * @param  string $app_key (required)
     * @param  \ZSGF\Client\ZSGF\Client\Model\ExecuteFunctionRequest|null $execute_function_request 函数请求参数 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageExecuteFunction'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storageExecuteFunctionAsync($nonce, $timestamp, $signature, $app_key, $execute_function_request = null, string $contentType = self::contentTypes['storageExecuteFunction'][0])
    {
        return $this->storageExecuteFunctionAsyncWithHttpInfo($nonce, $timestamp, $signature, $app_key, $execute_function_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storageExecuteFunctionAsyncWithHttpInfo
     *
     * 执行函数
     *
     * @param  string $nonce 随机字符串 (required)
     * @param  int $timestamp 时间戳 (required)
     * @param  string $signature 签名 (required)
     * @param  string $app_key (required)
     * @param  \ZSGF\Client\ZSGF\Client\Model\ExecuteFunctionRequest|null $execute_function_request 函数请求参数 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageExecuteFunction'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storageExecuteFunctionAsyncWithHttpInfo($nonce, $timestamp, $signature, $app_key, $execute_function_request = null, string $contentType = self::contentTypes['storageExecuteFunction'][0])
    {
        $returnType = '\ZSGF\Client\ZSGF\Client\Model\ObjectApiResponse';
        $request = $this->storageExecuteFunctionRequest($nonce, $timestamp, $signature, $app_key, $execute_function_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'storageExecuteFunction'
     *
     * @param  string $nonce 随机字符串 (required)
     * @param  int $timestamp 时间戳 (required)
     * @param  string $signature 签名 (required)
     * @param  string $app_key (required)
     * @param  \ZSGF\Client\ZSGF\Client\Model\ExecuteFunctionRequest|null $execute_function_request 函数请求参数 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageExecuteFunction'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function storageExecuteFunctionRequest($nonce, $timestamp, $signature, $app_key, $execute_function_request = null, string $contentType = self::contentTypes['storageExecuteFunction'][0])
    {

        // verify the required parameter 'nonce' is set
        if ($nonce === null || (is_array($nonce) && count($nonce) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $nonce when calling storageExecuteFunction'
            );
        }

        // verify the required parameter 'timestamp' is set
        if ($timestamp === null || (is_array($timestamp) && count($timestamp) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $timestamp when calling storageExecuteFunction'
            );
        }

        // verify the required parameter 'signature' is set
        if ($signature === null || (is_array($signature) && count($signature) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $signature when calling storageExecuteFunction'
            );
        }

        // verify the required parameter 'app_key' is set
        if ($app_key === null || (is_array($app_key) && count($app_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_key when calling storageExecuteFunction'
            );
        }



        $resourcePath = '/Storage/{appKey}/ExecuteFunction';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $nonce,
            'nonce', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $signature,
            'signature', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($app_key !== null) {
            $resourcePath = str_replace(
                '{' . 'appKey' . '}',
                ObjectSerializer::toPathValue($app_key),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($execute_function_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($execute_function_request));
            } else {
                $httpBody = $execute_function_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation storageExport
     *
     * 导出数据
     *
     * @param  string $table 表名称 (required)
     * @param  string $app_key app_key (required)
     * @param  string|null $filter 筛选条件，json格式 (optional)
     * @param  \DateTime|null $start_time 开始时间 (optional)
     * @param  \DateTime|null $end_time 结束时间 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageExport'] to see the possible values for this operation
     *
     * @throws \ZSGF\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function storageExport($table, $app_key, $filter = null, $start_time = null, $end_time = null, string $contentType = self::contentTypes['storageExport'][0])
    {
        list($response) = $this->storageExportWithHttpInfo($table, $app_key, $filter, $start_time, $end_time, $contentType);
        return $response;
    }

    /**
     * Operation storageExportWithHttpInfo
     *
     * 导出数据
     *
     * @param  string $table 表名称 (required)
     * @param  string $app_key (required)
     * @param  string|null $filter 筛选条件，json格式 (optional)
     * @param  \DateTime|null $start_time 开始时间 (optional)
     * @param  \DateTime|null $end_time 结束时间 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageExport'] to see the possible values for this operation
     *
     * @throws \ZSGF\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function storageExportWithHttpInfo($table, $app_key, $filter = null, $start_time = null, $end_time = null, string $contentType = self::contentTypes['storageExport'][0])
    {
        $request = $this->storageExportRequest($table, $app_key, $filter, $start_time, $end_time, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation storageExportAsync
     *
     * 导出数据
     *
     * @param  string $table 表名称 (required)
     * @param  string $app_key (required)
     * @param  string|null $filter 筛选条件，json格式 (optional)
     * @param  \DateTime|null $start_time 开始时间 (optional)
     * @param  \DateTime|null $end_time 结束时间 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageExport'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storageExportAsync($table, $app_key, $filter = null, $start_time = null, $end_time = null, string $contentType = self::contentTypes['storageExport'][0])
    {
        return $this->storageExportAsyncWithHttpInfo($table, $app_key, $filter, $start_time, $end_time, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storageExportAsyncWithHttpInfo
     *
     * 导出数据
     *
     * @param  string $table 表名称 (required)
     * @param  string $app_key (required)
     * @param  string|null $filter 筛选条件，json格式 (optional)
     * @param  \DateTime|null $start_time 开始时间 (optional)
     * @param  \DateTime|null $end_time 结束时间 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageExport'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storageExportAsyncWithHttpInfo($table, $app_key, $filter = null, $start_time = null, $end_time = null, string $contentType = self::contentTypes['storageExport'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->storageExportRequest($table, $app_key, $filter, $start_time, $end_time, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'storageExport'
     *
     * @param  string $table 表名称 (required)
     * @param  string $app_key (required)
     * @param  string|null $filter 筛选条件，json格式 (optional)
     * @param  \DateTime|null $start_time 开始时间 (optional)
     * @param  \DateTime|null $end_time 结束时间 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageExport'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function storageExportRequest($table, $app_key, $filter = null, $start_time = null, $end_time = null, string $contentType = self::contentTypes['storageExport'][0])
    {

        // verify the required parameter 'table' is set
        if ($table === null || (is_array($table) && count($table) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $table when calling storageExport'
            );
        }
        if (!preg_match("/^[a-zA-Z0-9_-]{1,100}$/", $table)) {
            throw new \InvalidArgumentException("invalid value for \"table\" when calling StorageApi.storageExport, must conform to the pattern /^[a-zA-Z0-9_-]{1,100}$/.");
        }
        
        // verify the required parameter 'app_key' is set
        if ($app_key === null || (is_array($app_key) && count($app_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_key when calling storageExport'
            );
        }





        $resourcePath = '/Storage/{appKey}/{table}/Export';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $filter,
            'filter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_time,
            'startTime', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_time,
            'endTime', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($table !== null) {
            $resourcePath = str_replace(
                '{' . 'table' . '}',
                ObjectSerializer::toPathValue($table),
                $resourcePath
            );
        }
        // path params
        if ($app_key !== null) {
            $resourcePath = str_replace(
                '{' . 'appKey' . '}',
                ObjectSerializer::toPathValue($app_key),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation storageImport
     *
     * 导入数据
     *
     * @param  string $table 表名称 (required)
     * @param  string $app_key app_key (required)
     * @param  \SplFileObject|null $file 导入的文件 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageImport'] to see the possible values for this operation
     *
     * @throws \ZSGF\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \ZSGF\Client\ZSGF\Client\Model\BooleanApiResponse
     */
    public function storageImport($table, $app_key, $file = null, string $contentType = self::contentTypes['storageImport'][0])
    {
        list($response) = $this->storageImportWithHttpInfo($table, $app_key, $file, $contentType);
        return $response;
    }

    /**
     * Operation storageImportWithHttpInfo
     *
     * 导入数据
     *
     * @param  string $table 表名称 (required)
     * @param  string $app_key (required)
     * @param  \SplFileObject|null $file 导入的文件 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageImport'] to see the possible values for this operation
     *
     * @throws \ZSGF\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \ZSGF\Client\ZSGF\Client\Model\BooleanApiResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function storageImportWithHttpInfo($table, $app_key, $file = null, string $contentType = self::contentTypes['storageImport'][0])
    {
        $request = $this->storageImportRequest($table, $app_key, $file, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\ZSGF\Client\ZSGF\Client\Model\BooleanApiResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ZSGF\Client\ZSGF\Client\Model\BooleanApiResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ZSGF\Client\ZSGF\Client\Model\BooleanApiResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\ZSGF\Client\ZSGF\Client\Model\BooleanApiResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ZSGF\Client\ZSGF\Client\Model\BooleanApiResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation storageImportAsync
     *
     * 导入数据
     *
     * @param  string $table 表名称 (required)
     * @param  string $app_key (required)
     * @param  \SplFileObject|null $file 导入的文件 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageImport'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storageImportAsync($table, $app_key, $file = null, string $contentType = self::contentTypes['storageImport'][0])
    {
        return $this->storageImportAsyncWithHttpInfo($table, $app_key, $file, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storageImportAsyncWithHttpInfo
     *
     * 导入数据
     *
     * @param  string $table 表名称 (required)
     * @param  string $app_key (required)
     * @param  \SplFileObject|null $file 导入的文件 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageImport'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storageImportAsyncWithHttpInfo($table, $app_key, $file = null, string $contentType = self::contentTypes['storageImport'][0])
    {
        $returnType = '\ZSGF\Client\ZSGF\Client\Model\BooleanApiResponse';
        $request = $this->storageImportRequest($table, $app_key, $file, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'storageImport'
     *
     * @param  string $table 表名称 (required)
     * @param  string $app_key (required)
     * @param  \SplFileObject|null $file 导入的文件 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageImport'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function storageImportRequest($table, $app_key, $file = null, string $contentType = self::contentTypes['storageImport'][0])
    {

        // verify the required parameter 'table' is set
        if ($table === null || (is_array($table) && count($table) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $table when calling storageImport'
            );
        }
        if (!preg_match("/^[a-zA-Z0-9_-]{1,100}$/", $table)) {
            throw new \InvalidArgumentException("invalid value for \"table\" when calling StorageApi.storageImport, must conform to the pattern /^[a-zA-Z0-9_-]{1,100}$/.");
        }
        
        // verify the required parameter 'app_key' is set
        if ($app_key === null || (is_array($app_key) && count($app_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_key when calling storageImport'
            );
        }



        $resourcePath = '/Storage/{appKey}/{table}/Import';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($table !== null) {
            $resourcePath = str_replace(
                '{' . 'table' . '}',
                ObjectSerializer::toPathValue($table),
                $resourcePath
            );
        }
        // path params
        if ($app_key !== null) {
            $resourcePath = str_replace(
                '{' . 'appKey' . '}',
                ObjectSerializer::toPathValue($app_key),
                $resourcePath
            );
        }

        // form params
        if ($file !== null) {
            $multipart = true;
            $formParams['file'] = [];
            $paramFiles = is_array($file) ? $file : [$file];
            foreach ($paramFiles as $paramFile) {
                $formParams['file'][] = \GuzzleHttp\Psr7\Utils::tryFopen(
                    ObjectSerializer::toFormValue($paramFile),
                    'rb'
                );
            }
        }

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation storageIndexes
     *
     * 获取索引
     *
     * @param  string $table 表名称 (required)
     * @param  string $app_key app_key (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageIndexes'] to see the possible values for this operation
     *
     * @throws \ZSGF\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \ZSGF\Client\ZSGF\Client\Model\ObjectListApiResponse
     */
    public function storageIndexes($table, $app_key, string $contentType = self::contentTypes['storageIndexes'][0])
    {
        list($response) = $this->storageIndexesWithHttpInfo($table, $app_key, $contentType);
        return $response;
    }

    /**
     * Operation storageIndexesWithHttpInfo
     *
     * 获取索引
     *
     * @param  string $table 表名称 (required)
     * @param  string $app_key (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageIndexes'] to see the possible values for this operation
     *
     * @throws \ZSGF\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \ZSGF\Client\ZSGF\Client\Model\ObjectListApiResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function storageIndexesWithHttpInfo($table, $app_key, string $contentType = self::contentTypes['storageIndexes'][0])
    {
        $request = $this->storageIndexesRequest($table, $app_key, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\ZSGF\Client\ZSGF\Client\Model\ObjectListApiResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ZSGF\Client\ZSGF\Client\Model\ObjectListApiResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ZSGF\Client\ZSGF\Client\Model\ObjectListApiResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\ZSGF\Client\ZSGF\Client\Model\ObjectListApiResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ZSGF\Client\ZSGF\Client\Model\ObjectListApiResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation storageIndexesAsync
     *
     * 获取索引
     *
     * @param  string $table 表名称 (required)
     * @param  string $app_key (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageIndexes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storageIndexesAsync($table, $app_key, string $contentType = self::contentTypes['storageIndexes'][0])
    {
        return $this->storageIndexesAsyncWithHttpInfo($table, $app_key, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storageIndexesAsyncWithHttpInfo
     *
     * 获取索引
     *
     * @param  string $table 表名称 (required)
     * @param  string $app_key (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageIndexes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storageIndexesAsyncWithHttpInfo($table, $app_key, string $contentType = self::contentTypes['storageIndexes'][0])
    {
        $returnType = '\ZSGF\Client\ZSGF\Client\Model\ObjectListApiResponse';
        $request = $this->storageIndexesRequest($table, $app_key, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'storageIndexes'
     *
     * @param  string $table 表名称 (required)
     * @param  string $app_key (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageIndexes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function storageIndexesRequest($table, $app_key, string $contentType = self::contentTypes['storageIndexes'][0])
    {

        // verify the required parameter 'table' is set
        if ($table === null || (is_array($table) && count($table) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $table when calling storageIndexes'
            );
        }
        if (!preg_match("/^[a-zA-Z0-9_-]{1,100}$/", $table)) {
            throw new \InvalidArgumentException("invalid value for \"table\" when calling StorageApi.storageIndexes, must conform to the pattern /^[a-zA-Z0-9_-]{1,100}$/.");
        }
        
        // verify the required parameter 'app_key' is set
        if ($app_key === null || (is_array($app_key) && count($app_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_key when calling storageIndexes'
            );
        }


        $resourcePath = '/Storage/{appKey}/{table}/Indexes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($table !== null) {
            $resourcePath = str_replace(
                '{' . 'table' . '}',
                ObjectSerializer::toPathValue($table),
                $resourcePath
            );
        }
        // path params
        if ($app_key !== null) {
            $resourcePath = str_replace(
                '{' . 'appKey' . '}',
                ObjectSerializer::toPathValue($app_key),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation storageList
     *
     * 查询数据
     *
     * @param  string $table 表名称 (required)
     * @param  string $app_key app_key (required)
     * @param  string|null $filter 过滤，json格式 (optional)
     * @param  string|null $project 字段映射，json格式 (optional)
     * @param  string|null $sort 排序，json格式 (optional)
     * @param  \DateTime|null $start_time 开始时间 (optional)
     * @param  \DateTime|null $end_time 结束时间 (optional)
     * @param  bool|null $explain 查看执行计划 (optional, default to false)
     * @param  int|null $take 默认为10 (optional, default to 10)
     * @param  int|null $skip 默认为0 (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageList'] to see the possible values for this operation
     *
     * @throws \ZSGF\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \ZSGF\Client\ZSGF\Client\Model\StorageListResultApiResponse
     */
    public function storageList($table, $app_key, $filter = null, $project = null, $sort = null, $start_time = null, $end_time = null, $explain = false, $take = 10, $skip = 0, string $contentType = self::contentTypes['storageList'][0])
    {
        list($response) = $this->storageListWithHttpInfo($table, $app_key, $filter, $project, $sort, $start_time, $end_time, $explain, $take, $skip, $contentType);
        return $response;
    }

    /**
     * Operation storageListWithHttpInfo
     *
     * 查询数据
     *
     * @param  string $table 表名称 (required)
     * @param  string $app_key (required)
     * @param  string|null $filter 过滤，json格式 (optional)
     * @param  string|null $project 字段映射，json格式 (optional)
     * @param  string|null $sort 排序，json格式 (optional)
     * @param  \DateTime|null $start_time 开始时间 (optional)
     * @param  \DateTime|null $end_time 结束时间 (optional)
     * @param  bool|null $explain 查看执行计划 (optional, default to false)
     * @param  int|null $take 默认为10 (optional, default to 10)
     * @param  int|null $skip 默认为0 (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageList'] to see the possible values for this operation
     *
     * @throws \ZSGF\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \ZSGF\Client\ZSGF\Client\Model\StorageListResultApiResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function storageListWithHttpInfo($table, $app_key, $filter = null, $project = null, $sort = null, $start_time = null, $end_time = null, $explain = false, $take = 10, $skip = 0, string $contentType = self::contentTypes['storageList'][0])
    {
        $request = $this->storageListRequest($table, $app_key, $filter, $project, $sort, $start_time, $end_time, $explain, $take, $skip, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\ZSGF\Client\ZSGF\Client\Model\StorageListResultApiResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ZSGF\Client\ZSGF\Client\Model\StorageListResultApiResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ZSGF\Client\ZSGF\Client\Model\StorageListResultApiResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\ZSGF\Client\ZSGF\Client\Model\StorageListResultApiResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ZSGF\Client\ZSGF\Client\Model\StorageListResultApiResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation storageListAsync
     *
     * 查询数据
     *
     * @param  string $table 表名称 (required)
     * @param  string $app_key (required)
     * @param  string|null $filter 过滤，json格式 (optional)
     * @param  string|null $project 字段映射，json格式 (optional)
     * @param  string|null $sort 排序，json格式 (optional)
     * @param  \DateTime|null $start_time 开始时间 (optional)
     * @param  \DateTime|null $end_time 结束时间 (optional)
     * @param  bool|null $explain 查看执行计划 (optional, default to false)
     * @param  int|null $take 默认为10 (optional, default to 10)
     * @param  int|null $skip 默认为0 (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storageListAsync($table, $app_key, $filter = null, $project = null, $sort = null, $start_time = null, $end_time = null, $explain = false, $take = 10, $skip = 0, string $contentType = self::contentTypes['storageList'][0])
    {
        return $this->storageListAsyncWithHttpInfo($table, $app_key, $filter, $project, $sort, $start_time, $end_time, $explain, $take, $skip, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storageListAsyncWithHttpInfo
     *
     * 查询数据
     *
     * @param  string $table 表名称 (required)
     * @param  string $app_key (required)
     * @param  string|null $filter 过滤，json格式 (optional)
     * @param  string|null $project 字段映射，json格式 (optional)
     * @param  string|null $sort 排序，json格式 (optional)
     * @param  \DateTime|null $start_time 开始时间 (optional)
     * @param  \DateTime|null $end_time 结束时间 (optional)
     * @param  bool|null $explain 查看执行计划 (optional, default to false)
     * @param  int|null $take 默认为10 (optional, default to 10)
     * @param  int|null $skip 默认为0 (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storageListAsyncWithHttpInfo($table, $app_key, $filter = null, $project = null, $sort = null, $start_time = null, $end_time = null, $explain = false, $take = 10, $skip = 0, string $contentType = self::contentTypes['storageList'][0])
    {
        $returnType = '\ZSGF\Client\ZSGF\Client\Model\StorageListResultApiResponse';
        $request = $this->storageListRequest($table, $app_key, $filter, $project, $sort, $start_time, $end_time, $explain, $take, $skip, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'storageList'
     *
     * @param  string $table 表名称 (required)
     * @param  string $app_key (required)
     * @param  string|null $filter 过滤，json格式 (optional)
     * @param  string|null $project 字段映射，json格式 (optional)
     * @param  string|null $sort 排序，json格式 (optional)
     * @param  \DateTime|null $start_time 开始时间 (optional)
     * @param  \DateTime|null $end_time 结束时间 (optional)
     * @param  bool|null $explain 查看执行计划 (optional, default to false)
     * @param  int|null $take 默认为10 (optional, default to 10)
     * @param  int|null $skip 默认为0 (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function storageListRequest($table, $app_key, $filter = null, $project = null, $sort = null, $start_time = null, $end_time = null, $explain = false, $take = 10, $skip = 0, string $contentType = self::contentTypes['storageList'][0])
    {

        // verify the required parameter 'table' is set
        if ($table === null || (is_array($table) && count($table) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $table when calling storageList'
            );
        }
        if (!preg_match("/^[a-zA-Z0-9_-]{1,100}$/", $table)) {
            throw new \InvalidArgumentException("invalid value for \"table\" when calling StorageApi.storageList, must conform to the pattern /^[a-zA-Z0-9_-]{1,100}$/.");
        }
        
        // verify the required parameter 'app_key' is set
        if ($app_key === null || (is_array($app_key) && count($app_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_key when calling storageList'
            );
        }










        $resourcePath = '/Storage/{appKey}/{table}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $filter,
            'filter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $project,
            'project', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_time,
            'startTime', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_time,
            'endTime', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $explain,
            'explain', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $take,
            'take', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $skip,
            'skip', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($table !== null) {
            $resourcePath = str_replace(
                '{' . 'table' . '}',
                ObjectSerializer::toPathValue($table),
                $resourcePath
            );
        }
        // path params
        if ($app_key !== null) {
            $resourcePath = str_replace(
                '{' . 'appKey' . '}',
                ObjectSerializer::toPathValue($app_key),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation storagePost
     *
     * 添加数据
     *
     * @param  string $table 表名称（小写字母加数字,1-50位） (required)
     * @param  string $app_key app_key (required)
     * @param  mixed[] $request_body json对象 / json数组 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storagePost'] to see the possible values for this operation
     *
     * @throws \ZSGF\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \ZSGF\Client\ZSGF\Client\Model\StringApiResponse
     */
    public function storagePost($table, $app_key, $request_body, string $contentType = self::contentTypes['storagePost'][0])
    {
        list($response) = $this->storagePostWithHttpInfo($table, $app_key, $request_body, $contentType);
        return $response;
    }

    /**
     * Operation storagePostWithHttpInfo
     *
     * 添加数据
     *
     * @param  string $table 表名称（小写字母加数字,1-50位） (required)
     * @param  string $app_key (required)
     * @param  mixed[] $request_body json对象 / json数组 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storagePost'] to see the possible values for this operation
     *
     * @throws \ZSGF\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \ZSGF\Client\ZSGF\Client\Model\StringApiResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function storagePostWithHttpInfo($table, $app_key, $request_body, string $contentType = self::contentTypes['storagePost'][0])
    {
        $request = $this->storagePostRequest($table, $app_key, $request_body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\ZSGF\Client\ZSGF\Client\Model\StringApiResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ZSGF\Client\ZSGF\Client\Model\StringApiResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ZSGF\Client\ZSGF\Client\Model\StringApiResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\ZSGF\Client\ZSGF\Client\Model\StringApiResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ZSGF\Client\ZSGF\Client\Model\StringApiResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation storagePostAsync
     *
     * 添加数据
     *
     * @param  string $table 表名称（小写字母加数字,1-50位） (required)
     * @param  string $app_key (required)
     * @param  mixed[] $request_body json对象 / json数组 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storagePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storagePostAsync($table, $app_key, $request_body, string $contentType = self::contentTypes['storagePost'][0])
    {
        return $this->storagePostAsyncWithHttpInfo($table, $app_key, $request_body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storagePostAsyncWithHttpInfo
     *
     * 添加数据
     *
     * @param  string $table 表名称（小写字母加数字,1-50位） (required)
     * @param  string $app_key (required)
     * @param  mixed[] $request_body json对象 / json数组 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storagePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storagePostAsyncWithHttpInfo($table, $app_key, $request_body, string $contentType = self::contentTypes['storagePost'][0])
    {
        $returnType = '\ZSGF\Client\ZSGF\Client\Model\StringApiResponse';
        $request = $this->storagePostRequest($table, $app_key, $request_body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'storagePost'
     *
     * @param  string $table 表名称（小写字母加数字,1-50位） (required)
     * @param  string $app_key (required)
     * @param  mixed[] $request_body json对象 / json数组 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storagePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function storagePostRequest($table, $app_key, $request_body, string $contentType = self::contentTypes['storagePost'][0])
    {

        // verify the required parameter 'table' is set
        if ($table === null || (is_array($table) && count($table) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $table when calling storagePost'
            );
        }
        if (!preg_match("/^[a-zA-Z0-9_-]{1,100}$/", $table)) {
            throw new \InvalidArgumentException("invalid value for \"table\" when calling StorageApi.storagePost, must conform to the pattern /^[a-zA-Z0-9_-]{1,100}$/.");
        }
        
        // verify the required parameter 'app_key' is set
        if ($app_key === null || (is_array($app_key) && count($app_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_key when calling storagePost'
            );
        }

        // verify the required parameter 'request_body' is set
        if ($request_body === null || (is_array($request_body) && count($request_body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request_body when calling storagePost'
            );
        }


        $resourcePath = '/Storage/{appKey}/{table}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($table !== null) {
            $resourcePath = str_replace(
                '{' . 'table' . '}',
                ObjectSerializer::toPathValue($table),
                $resourcePath
            );
        }
        // path params
        if ($app_key !== null) {
            $resourcePath = str_replace(
                '{' . 'appKey' . '}',
                ObjectSerializer::toPathValue($app_key),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($request_body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($request_body));
            } else {
                $httpBody = $request_body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation storagePostIndex
     *
     * 添加索引
     *
     * @param  string $table 表名称（小写字母加数字,1-50位） (required)
     * @param  string $app_key app_key (required)
     * @param  \ZSGF\Client\ZSGF\Client\Model\PostIndexRequest|null $post_index_request json对象 / json数组 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storagePostIndex'] to see the possible values for this operation
     *
     * @throws \ZSGF\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \ZSGF\Client\ZSGF\Client\Model\StringApiResponse
     */
    public function storagePostIndex($table, $app_key, $post_index_request = null, string $contentType = self::contentTypes['storagePostIndex'][0])
    {
        list($response) = $this->storagePostIndexWithHttpInfo($table, $app_key, $post_index_request, $contentType);
        return $response;
    }

    /**
     * Operation storagePostIndexWithHttpInfo
     *
     * 添加索引
     *
     * @param  string $table 表名称（小写字母加数字,1-50位） (required)
     * @param  string $app_key (required)
     * @param  \ZSGF\Client\ZSGF\Client\Model\PostIndexRequest|null $post_index_request json对象 / json数组 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storagePostIndex'] to see the possible values for this operation
     *
     * @throws \ZSGF\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \ZSGF\Client\ZSGF\Client\Model\StringApiResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function storagePostIndexWithHttpInfo($table, $app_key, $post_index_request = null, string $contentType = self::contentTypes['storagePostIndex'][0])
    {
        $request = $this->storagePostIndexRequest($table, $app_key, $post_index_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\ZSGF\Client\ZSGF\Client\Model\StringApiResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ZSGF\Client\ZSGF\Client\Model\StringApiResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ZSGF\Client\ZSGF\Client\Model\StringApiResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\ZSGF\Client\ZSGF\Client\Model\StringApiResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ZSGF\Client\ZSGF\Client\Model\StringApiResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation storagePostIndexAsync
     *
     * 添加索引
     *
     * @param  string $table 表名称（小写字母加数字,1-50位） (required)
     * @param  string $app_key (required)
     * @param  \ZSGF\Client\ZSGF\Client\Model\PostIndexRequest|null $post_index_request json对象 / json数组 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storagePostIndex'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storagePostIndexAsync($table, $app_key, $post_index_request = null, string $contentType = self::contentTypes['storagePostIndex'][0])
    {
        return $this->storagePostIndexAsyncWithHttpInfo($table, $app_key, $post_index_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storagePostIndexAsyncWithHttpInfo
     *
     * 添加索引
     *
     * @param  string $table 表名称（小写字母加数字,1-50位） (required)
     * @param  string $app_key (required)
     * @param  \ZSGF\Client\ZSGF\Client\Model\PostIndexRequest|null $post_index_request json对象 / json数组 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storagePostIndex'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storagePostIndexAsyncWithHttpInfo($table, $app_key, $post_index_request = null, string $contentType = self::contentTypes['storagePostIndex'][0])
    {
        $returnType = '\ZSGF\Client\ZSGF\Client\Model\StringApiResponse';
        $request = $this->storagePostIndexRequest($table, $app_key, $post_index_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'storagePostIndex'
     *
     * @param  string $table 表名称（小写字母加数字,1-50位） (required)
     * @param  string $app_key (required)
     * @param  \ZSGF\Client\ZSGF\Client\Model\PostIndexRequest|null $post_index_request json对象 / json数组 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storagePostIndex'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function storagePostIndexRequest($table, $app_key, $post_index_request = null, string $contentType = self::contentTypes['storagePostIndex'][0])
    {

        // verify the required parameter 'table' is set
        if ($table === null || (is_array($table) && count($table) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $table when calling storagePostIndex'
            );
        }
        if (!preg_match("/^[a-zA-Z0-9_-]{1,100}$/", $table)) {
            throw new \InvalidArgumentException("invalid value for \"table\" when calling StorageApi.storagePostIndex, must conform to the pattern /^[a-zA-Z0-9_-]{1,100}$/.");
        }
        
        // verify the required parameter 'app_key' is set
        if ($app_key === null || (is_array($app_key) && count($app_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_key when calling storagePostIndex'
            );
        }



        $resourcePath = '/Storage/{appKey}/{table}/indexes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($table !== null) {
            $resourcePath = str_replace(
                '{' . 'table' . '}',
                ObjectSerializer::toPathValue($table),
                $resourcePath
            );
        }
        // path params
        if ($app_key !== null) {
            $resourcePath = str_replace(
                '{' . 'appKey' . '}',
                ObjectSerializer::toPathValue($app_key),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_index_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_index_request));
            } else {
                $httpBody = $post_index_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation storagePut
     *
     * 更新数据
     *
     * @param  string $table 表名称 (required)
     * @param  string $id 数据ID (required)
     * @param  string $app_key app_key (required)
     * @param  mixed[] $request_body json格式 (required)
     * @param  bool|null $replace 是否为全量更新，默认为false (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storagePut'] to see the possible values for this operation
     *
     * @throws \ZSGF\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \ZSGF\Client\ZSGF\Client\Model\BooleanApiResponse
     */
    public function storagePut($table, $id, $app_key, $request_body, $replace = false, string $contentType = self::contentTypes['storagePut'][0])
    {
        list($response) = $this->storagePutWithHttpInfo($table, $id, $app_key, $request_body, $replace, $contentType);
        return $response;
    }

    /**
     * Operation storagePutWithHttpInfo
     *
     * 更新数据
     *
     * @param  string $table 表名称 (required)
     * @param  string $id 数据ID (required)
     * @param  string $app_key (required)
     * @param  mixed[] $request_body json格式 (required)
     * @param  bool|null $replace 是否为全量更新，默认为false (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storagePut'] to see the possible values for this operation
     *
     * @throws \ZSGF\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \ZSGF\Client\ZSGF\Client\Model\BooleanApiResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function storagePutWithHttpInfo($table, $id, $app_key, $request_body, $replace = false, string $contentType = self::contentTypes['storagePut'][0])
    {
        $request = $this->storagePutRequest($table, $id, $app_key, $request_body, $replace, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\ZSGF\Client\ZSGF\Client\Model\BooleanApiResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ZSGF\Client\ZSGF\Client\Model\BooleanApiResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ZSGF\Client\ZSGF\Client\Model\BooleanApiResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\ZSGF\Client\ZSGF\Client\Model\BooleanApiResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ZSGF\Client\ZSGF\Client\Model\BooleanApiResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation storagePutAsync
     *
     * 更新数据
     *
     * @param  string $table 表名称 (required)
     * @param  string $id 数据ID (required)
     * @param  string $app_key (required)
     * @param  mixed[] $request_body json格式 (required)
     * @param  bool|null $replace 是否为全量更新，默认为false (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storagePut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storagePutAsync($table, $id, $app_key, $request_body, $replace = false, string $contentType = self::contentTypes['storagePut'][0])
    {
        return $this->storagePutAsyncWithHttpInfo($table, $id, $app_key, $request_body, $replace, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storagePutAsyncWithHttpInfo
     *
     * 更新数据
     *
     * @param  string $table 表名称 (required)
     * @param  string $id 数据ID (required)
     * @param  string $app_key (required)
     * @param  mixed[] $request_body json格式 (required)
     * @param  bool|null $replace 是否为全量更新，默认为false (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storagePut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storagePutAsyncWithHttpInfo($table, $id, $app_key, $request_body, $replace = false, string $contentType = self::contentTypes['storagePut'][0])
    {
        $returnType = '\ZSGF\Client\ZSGF\Client\Model\BooleanApiResponse';
        $request = $this->storagePutRequest($table, $id, $app_key, $request_body, $replace, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'storagePut'
     *
     * @param  string $table 表名称 (required)
     * @param  string $id 数据ID (required)
     * @param  string $app_key (required)
     * @param  mixed[] $request_body json格式 (required)
     * @param  bool|null $replace 是否为全量更新，默认为false (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storagePut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function storagePutRequest($table, $id, $app_key, $request_body, $replace = false, string $contentType = self::contentTypes['storagePut'][0])
    {

        // verify the required parameter 'table' is set
        if ($table === null || (is_array($table) && count($table) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $table when calling storagePut'
            );
        }
        if (!preg_match("/^[a-zA-Z0-9_-]{1,100}$/", $table)) {
            throw new \InvalidArgumentException("invalid value for \"table\" when calling StorageApi.storagePut, must conform to the pattern /^[a-zA-Z0-9_-]{1,100}$/.");
        }
        
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling storagePut'
            );
        }

        // verify the required parameter 'app_key' is set
        if ($app_key === null || (is_array($app_key) && count($app_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_key when calling storagePut'
            );
        }

        // verify the required parameter 'request_body' is set
        if ($request_body === null || (is_array($request_body) && count($request_body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request_body when calling storagePut'
            );
        }



        $resourcePath = '/Storage/{appKey}/{table}/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $replace,
            'replace', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($table !== null) {
            $resourcePath = str_replace(
                '{' . 'table' . '}',
                ObjectSerializer::toPathValue($table),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($app_key !== null) {
            $resourcePath = str_replace(
                '{' . 'appKey' . '}',
                ObjectSerializer::toPathValue($app_key),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($request_body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($request_body));
            } else {
                $httpBody = $request_body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation storageRemove
     *
     * 删除表
     *
     * @param  string $table 表名称 (required)
     * @param  string $app_key app_key (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageRemove'] to see the possible values for this operation
     *
     * @throws \ZSGF\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \ZSGF\Client\ZSGF\Client\Model\BooleanApiResponse
     */
    public function storageRemove($table, $app_key, string $contentType = self::contentTypes['storageRemove'][0])
    {
        list($response) = $this->storageRemoveWithHttpInfo($table, $app_key, $contentType);
        return $response;
    }

    /**
     * Operation storageRemoveWithHttpInfo
     *
     * 删除表
     *
     * @param  string $table 表名称 (required)
     * @param  string $app_key (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageRemove'] to see the possible values for this operation
     *
     * @throws \ZSGF\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \ZSGF\Client\ZSGF\Client\Model\BooleanApiResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function storageRemoveWithHttpInfo($table, $app_key, string $contentType = self::contentTypes['storageRemove'][0])
    {
        $request = $this->storageRemoveRequest($table, $app_key, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\ZSGF\Client\ZSGF\Client\Model\BooleanApiResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ZSGF\Client\ZSGF\Client\Model\BooleanApiResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ZSGF\Client\ZSGF\Client\Model\BooleanApiResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\ZSGF\Client\ZSGF\Client\Model\BooleanApiResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ZSGF\Client\ZSGF\Client\Model\BooleanApiResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation storageRemoveAsync
     *
     * 删除表
     *
     * @param  string $table 表名称 (required)
     * @param  string $app_key (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageRemove'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storageRemoveAsync($table, $app_key, string $contentType = self::contentTypes['storageRemove'][0])
    {
        return $this->storageRemoveAsyncWithHttpInfo($table, $app_key, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storageRemoveAsyncWithHttpInfo
     *
     * 删除表
     *
     * @param  string $table 表名称 (required)
     * @param  string $app_key (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageRemove'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storageRemoveAsyncWithHttpInfo($table, $app_key, string $contentType = self::contentTypes['storageRemove'][0])
    {
        $returnType = '\ZSGF\Client\ZSGF\Client\Model\BooleanApiResponse';
        $request = $this->storageRemoveRequest($table, $app_key, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'storageRemove'
     *
     * @param  string $table 表名称 (required)
     * @param  string $app_key (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageRemove'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function storageRemoveRequest($table, $app_key, string $contentType = self::contentTypes['storageRemove'][0])
    {

        // verify the required parameter 'table' is set
        if ($table === null || (is_array($table) && count($table) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $table when calling storageRemove'
            );
        }
        if (!preg_match("/^[a-zA-Z0-9_-]{1,100}$/", $table)) {
            throw new \InvalidArgumentException("invalid value for \"table\" when calling StorageApi.storageRemove, must conform to the pattern /^[a-zA-Z0-9_-]{1,100}$/.");
        }
        
        // verify the required parameter 'app_key' is set
        if ($app_key === null || (is_array($app_key) && count($app_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_key when calling storageRemove'
            );
        }


        $resourcePath = '/Storage/{appKey}/{table}/Remove';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($table !== null) {
            $resourcePath = str_replace(
                '{' . 'table' . '}',
                ObjectSerializer::toPathValue($table),
                $resourcePath
            );
        }
        // path params
        if ($app_key !== null) {
            $resourcePath = str_replace(
                '{' . 'appKey' . '}',
                ObjectSerializer::toPathValue($app_key),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation storageStats
     *
     * 数据表统计
     *
     * @param  string $table 表名称 (required)
     * @param  string $app_key app_key (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageStats'] to see the possible values for this operation
     *
     * @throws \ZSGF\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \ZSGF\Client\ZSGF\Client\Model\ObjectApiResponse
     */
    public function storageStats($table, $app_key, string $contentType = self::contentTypes['storageStats'][0])
    {
        list($response) = $this->storageStatsWithHttpInfo($table, $app_key, $contentType);
        return $response;
    }

    /**
     * Operation storageStatsWithHttpInfo
     *
     * 数据表统计
     *
     * @param  string $table 表名称 (required)
     * @param  string $app_key (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageStats'] to see the possible values for this operation
     *
     * @throws \ZSGF\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \ZSGF\Client\ZSGF\Client\Model\ObjectApiResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function storageStatsWithHttpInfo($table, $app_key, string $contentType = self::contentTypes['storageStats'][0])
    {
        $request = $this->storageStatsRequest($table, $app_key, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\ZSGF\Client\ZSGF\Client\Model\ObjectApiResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ZSGF\Client\ZSGF\Client\Model\ObjectApiResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ZSGF\Client\ZSGF\Client\Model\ObjectApiResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\ZSGF\Client\ZSGF\Client\Model\ObjectApiResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ZSGF\Client\ZSGF\Client\Model\ObjectApiResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation storageStatsAsync
     *
     * 数据表统计
     *
     * @param  string $table 表名称 (required)
     * @param  string $app_key (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storageStatsAsync($table, $app_key, string $contentType = self::contentTypes['storageStats'][0])
    {
        return $this->storageStatsAsyncWithHttpInfo($table, $app_key, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storageStatsAsyncWithHttpInfo
     *
     * 数据表统计
     *
     * @param  string $table 表名称 (required)
     * @param  string $app_key (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storageStatsAsyncWithHttpInfo($table, $app_key, string $contentType = self::contentTypes['storageStats'][0])
    {
        $returnType = '\ZSGF\Client\ZSGF\Client\Model\ObjectApiResponse';
        $request = $this->storageStatsRequest($table, $app_key, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'storageStats'
     *
     * @param  string $table 表名称 (required)
     * @param  string $app_key (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function storageStatsRequest($table, $app_key, string $contentType = self::contentTypes['storageStats'][0])
    {

        // verify the required parameter 'table' is set
        if ($table === null || (is_array($table) && count($table) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $table when calling storageStats'
            );
        }
        if (!preg_match("/^[a-zA-Z0-9_-]{1,100}$/", $table)) {
            throw new \InvalidArgumentException("invalid value for \"table\" when calling StorageApi.storageStats, must conform to the pattern /^[a-zA-Z0-9_-]{1,100}$/.");
        }
        
        // verify the required parameter 'app_key' is set
        if ($app_key === null || (is_array($app_key) && count($app_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_key when calling storageStats'
            );
        }


        $resourcePath = '/Storage/{appKey}/{table}/Stats';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($table !== null) {
            $resourcePath = str_replace(
                '{' . 'table' . '}',
                ObjectSerializer::toPathValue($table),
                $resourcePath
            );
        }
        // path params
        if ($app_key !== null) {
            $resourcePath = str_replace(
                '{' . 'appKey' . '}',
                ObjectSerializer::toPathValue($app_key),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation storageTables
     *
     * 获取数据表
     *
     * @param  string $app_key app_key (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageTables'] to see the possible values for this operation
     *
     * @throws \ZSGF\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \ZSGF\Client\ZSGF\Client\Model\StringListApiResponse
     */
    public function storageTables($app_key, string $contentType = self::contentTypes['storageTables'][0])
    {
        list($response) = $this->storageTablesWithHttpInfo($app_key, $contentType);
        return $response;
    }

    /**
     * Operation storageTablesWithHttpInfo
     *
     * 获取数据表
     *
     * @param  string $app_key (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageTables'] to see the possible values for this operation
     *
     * @throws \ZSGF\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \ZSGF\Client\ZSGF\Client\Model\StringListApiResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function storageTablesWithHttpInfo($app_key, string $contentType = self::contentTypes['storageTables'][0])
    {
        $request = $this->storageTablesRequest($app_key, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\ZSGF\Client\ZSGF\Client\Model\StringListApiResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\ZSGF\Client\ZSGF\Client\Model\StringListApiResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ZSGF\Client\ZSGF\Client\Model\StringListApiResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\ZSGF\Client\ZSGF\Client\Model\StringListApiResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ZSGF\Client\ZSGF\Client\Model\StringListApiResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation storageTablesAsync
     *
     * 获取数据表
     *
     * @param  string $app_key (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageTables'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storageTablesAsync($app_key, string $contentType = self::contentTypes['storageTables'][0])
    {
        return $this->storageTablesAsyncWithHttpInfo($app_key, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storageTablesAsyncWithHttpInfo
     *
     * 获取数据表
     *
     * @param  string $app_key (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageTables'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storageTablesAsyncWithHttpInfo($app_key, string $contentType = self::contentTypes['storageTables'][0])
    {
        $returnType = '\ZSGF\Client\ZSGF\Client\Model\StringListApiResponse';
        $request = $this->storageTablesRequest($app_key, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'storageTables'
     *
     * @param  string $app_key (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storageTables'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function storageTablesRequest($app_key, string $contentType = self::contentTypes['storageTables'][0])
    {

        // verify the required parameter 'app_key' is set
        if ($app_key === null || (is_array($app_key) && count($app_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_key when calling storageTables'
            );
        }


        $resourcePath = '/Storage/{appKey}/Tables';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($app_key !== null) {
            $resourcePath = str_replace(
                '{' . 'appKey' . '}',
                ObjectSerializer::toPathValue($app_key),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
